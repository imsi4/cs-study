# chap2. Operating-System Structures

> OS는 프로그램을 작동하는 환경을 제공한다. 새로운 OS 디자인은 이전의 잘 짜여진 OS보다  낳아진 환경을 제공하기위해 다양한 알고리즘 과 전략의 선택을 기초로 만들어진다.

## 목차

- OS가 제공하는 서비스 정의
- OS 시스템의 서비스를 제공하기 위해 시스템 콜을 주는지
- 

## 2.1 Operating-System Services

> OS는 프로그램 실행을 위해 환경을 제공한다. 프로그래머와 프로그램을 사용하는 유저가 프로그램을 이용가능하기위해 매우 중요한 서비스이다. 물론,  제공된 특정 서비스들은 운영체제 마다 다르지만, 공통의 클래스로 identify를 할 수 있다.
>
> OS services = user Interface + 시스템 함수 + 독립적인 시스템 프로그램

- User interface : 거의 모든 OS는 user interface(UI)를 갖고 있다. 여러 형태로 사용이 되는데, *graphical user interface(GUI)를 사용된다.  -> 마우스(direct I/O), 키보드의 엔터 등등
  -  모바일 시스템에서는 터치 스크린 인터페이스가 있음.. 손가락으로 터치터치(TUI - Touch User Interface)
  - 다른 옵션은 CLI(command-line interface)가 있습니다. 이건 뭐.. 이야기 안해도.. cmd 맞습니다ㅎㅎ terminal도 맞고요.
- 프로그램 실행 : 이 시스템은 프로그램을 메모리로 갖고 오고, 실행 시킬 수 있다. 정지도 가능하고.. 정지라 하면 정상적인 접근과 비정상적인 접근(error)과 같은..
- I/O operation : 말 그대로 Input/ouput을 의미하는 거고 인풋을 주면 아웃풋을 보내주는 장치? 장비?(입출력 장치) 들을 의미합니다. 특정 디바이스는 I/O operation을 필요로 합니다.  
- File-system manipulation : 파일 및 디렉토리 조작이라고나 할까? 프로그램은 파일을 읽고 쓰는 것을 필요로 한다. 또한 파일과 디렉토리를 생성 삭제기능 + 검색 + 파일 정도 등등 다양한 파일 관련 조작 을 OS에서 개입해 접근을 허용하거나 deny시키면서 조작을 하게 되는것.. 사실.. 나는 이게 제일 모르겠어.. 
- communications : 다른 프로세스의 정보를 교환하는데 많은 의사소통 방식이 있다..이러한 의사소통은 같은 컴퓨터의 다른 프로세스 사이에서 발생하기도 하고 네트워크를 통해 다른 컴퓨터끼리의 통신에서 발생하기도한다. 의사소통은 보통 *`shared memory`나 *`message passing`을 주로 이용한다. 내 기억으로 이게 나중에 자세하게 다루는걸로 알고 있어요ㅎㅎ
- Error detection : OS 시스템은 계속적으로 에러 감지와 해결하는 기능이 필요하다. 에러는 CPU와 메모리 하드웨어, 디스크의 I/O 등 다양한 방식을 통해 발생한다. 각각의 에러 타입 마다 적절한 행동이 진행되어야 하며 끊임 없이 확인하고 대응해야 한다. 가끔씩 해결 방법이 없어서 시스템이 멈추기도 한다. 다른시간에는 error-causing process를 멈추거나, 에러를 잡고 탐지하기 위해 에러코드를 return 시킨다.

사용자에 도움을 주는 목적 외에 시스템 자체의 효율적인 동작을 보장하기 위한 운영체제 기능들도 존재한다. 다수의 사용자가 사용하는 시스템에서는 사요자들 간에 컴퓨터 자원을 공유하게 함으로써 효율성을 얻을 수 있다.

- 리소스 할당 : 다수의 사용자나 다수의 작업들이 동시에 실행될 때, 그들 각각에 자원을 할당해 주어야 한다. 운영체제는 여러 가지 다른 종류의 자원을 관리한다. 어떤 것들은 특수한 할당 코드를 가질 수 있는 반면, 다른 것들(ex. 입출력 장치)은 훨씬 일반적인 요청과 코드를 갖을 수 있다. 구체적인 예시는  57p resource allocation부분을 참고
- Logging (=accounting): 우리는 사용자가 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있기를 원한다. 이와 같은 기록 관리를 의미하며 사용자에게 보여주고(like 청구서)  단순한 추척된 사용 통계를 위해 사용한다. 
- 보호와 보안 : 멀티 유저나 네트워크 컴퓨터 시스템에 의해 저장된 정보의 소유자들은 그 정보의 사용을 통제하길 원한다.(access 권한을 주거나 차단하거나..) 여러 분리된 프로세스들을 병행 하게 실행할때, 다른 프로세스나 operating system이 스스로 간섭하거나 방해 할 수 없다. 보호는 모든 시스템 자원에 접근을 통제하도록 보장하는 것을 포함한다. 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힌다. 만약, 시스템이 보호되고 보안이 유지 되려면, 시스템 전체에 걸쳐 예방책(procaution)이 제정되어야 한다.



## 2.2 사용자 운영체제 인터페이스

> 사용자가 운영체제에 접촉하는 방식
>
> 1. 명령어 라인 인터페이스(CLI) or 명령어 해석기(command interpreter) - 사용자가 운영체제가 수행할 명령어를 직접 입력할 수 있도록..
> 2. 그래피컬 사용자 인터페이스(GUI)

### 2.2.1 명령 해석기(command-interpretor)

  대부분의 운영체제(Linux, Unix, windows)는 작업을 시행하거나 사용자가(대화형 시스템 상에서) 처음으로 로그온 할 때 수행되는 특수한 프로그램으로 취급한다. 예를 들어 Bourne shell, C shell, Bourne Again shell, Korn shell 등... 사용자가 어느 shelll을 사용할 것인가를 결정하는 것은 개인의 취향에 따라 달라진다.

  명령어 해석기의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다. 이 수준에서 제공된 많은 명령들은 파일을 조작한다. 생성, 삭제, 리스트, 프린트, 복사, 수행 등등..

- 구현 방법..
  - 명령 해석기 자체가 명령을 실행할 코드를 갖고 있는 경우 - 명령 해석기가 자신의 코드의 한 부분으로 분기(jump)하고, 그 코드 부분이 매개변수를 설정하고 적절한 시스템 호출을 한다. 이 경우 제공될 수 있는 명령의 수가 명령 해석기의 크기를 결정하는데, 그 이유는 각 명령이 자신의 구현 코드를 요구하기 때문이다.
  - 시스템 프로그램에 의해 대부분의 명령을 구현하는 것. rm file.txt 와 같이 rm이라는 명령어가 정의 되어 있고 file.txt라는 매개변수를 설정함에 따라 파일을 삭제 하게 된다. 

### 2.2.2 Graphical User Interface

사용자 친화적인 GUI를 통한 방식을 의미한다.  데스크탑이라고 불리는 마우스를 기반으로 하는 윈도우 메뉴 시스템을 사용하는 것. 마우스 포인터의 위치와 클릭 등을 이용하여 프로그램을 호출하거나, 파일 혹은 디렉터리를 선택할수 있고 또는 명령을 포함한 메뉴를 사용할 수 있다.

### 2.2.3 Touch-Screen Interface

마우스, 키보는는 모바일 시스템에서는 사용하기 어려운 장치이기 때문에 터치 스크린 인터페이스를 사용한다.  말그대로 touch라는 gestures를 이용한 유저 인터페이스를 의미한다. iPhone or iPad는 Springboard touch-screen interface를 사용

### 2.2.4 Choice of Interface

- 컴퓨터를 관리자나 시스템의 깊은 지식을 갖고 있는 power user는 보통 CLI를 사용한다. 왜냐하면 그것들이 더 효율적이고 빠르게 실행에 접근할 수 있기 때문이다. 보통 반복적으로 해야하는 행동에 대해 CLI를 많이 사용한다. - Unix, Linux
- Windows는 GUI사용이 보편적이고 MS-DOS는 잘 사용하지 않는다.
- 역사적으로 Mac GUI만 사용하게 만들어 놨지만 현재는 Mac OS X의 출시로 현재는 Aqua 인터페이스와 명령어 라인 인터페이스를 함께 제공한다. 

## 2.3 시스템 호출(System Calls)

> system call은 OS에 의해 이용가능하게 만들어진 서비스를 제공한다. 특정 low-level의 task들(하드웨어를 직접 접근해야 하는 작업)은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C와 C++ 언어로 작성된 루틴 형태로 제공된다.

### 2.3.1 Example

작성된 한 파일로 부터 데이터를 읽어서 복사하는 간단한 프로그램을 예로 들어보자.

1. 여러가지 방법(CUI(character user interface), 마우스 기반의 시스템 등등)을 통해 입력 파일과 출력파일을 첫 번째 입력을 한다.
2. 두 개의 파일 이름이 얻어지면, 프로그램은 반드시 입력 파일을 오픈하고 출력 파일을 생성. 각각의 이러한 연산은 또 다른 시스템 호출을 필요로 하며, 각 연산에서 오류 조건이 발생할 수 있고 추가적인 시스템 호출을 필요로 한다. 다양한 오류 및 중단해야 하는 상황이 발생가능함.
3. 입력 파일로 부터 읽어서(하나의 시스템 호출), 출력 파일에 기록(또 다른 시스템 호출)하는 루프 실행
4. 전체 파일이 복사된 후, 프로그램은 두 개의 파일을 닫고(또 다른 시스템 호출), 콘솔 또는 윈도우에 메시지를 기록하고(추가의 시스템 호출들), 결국 정상적으로 종료(마지막 시스템 호출)

### 2.3.2 Application Programming Interface(API)

> 대부분의 응용 개발자들은 응용 프로그래밍 인터페이스(API)에 따라 프로그램을 설계한다. API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용프로그래머가 사용 가능한 함수의 집합을 명시한다.

- 응용 프로그래머는 실제 시스템 호출을 부르는 것보다 API에 따라 프로그래밍 하는 것을 선호하는 이유는? 
  - 프로그램의 호환성 관련 : API에 따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일 되고 실행된다는 것을 기대 할 수 있다.
  - 실제 시스템 호출은 애매모호 하지만(자세한 설명 및 이해가 필요),  API 함수 호출은 쉽다. 그럼에도 불구하고 API 함수를 호출하는 것과 *커널의 관련된 시스템 호출을 호출한 것에는  강한 상관관계가 있다.
- 시스템 호출 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 호출을 부른다. 통상 각 시스템 호출에는 번호가 할당되고 시스템 호출 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다. 시스템 호출 인터페이스는 의도하는 시스스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다.
- 운영체제에 매개변수를 전달하기 위해서 세 가지 일반적인 방법을 사용
  - 가장 간단한 방법은 매개변수를 레지스터 내에 전달하는 것
  - 레지스터보다 더 많은 매개 변수가 존재할 시 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달된다.
  - 매개변수는 프로그램에 의해 스택(Stack)에 push할 수 있고, 운영체제에 의해 pop off할 수 있다. 



### 2.3.3 시스템 호출의 유형

> 시스템 호출은 다섯 가지 중요한 범주를 갖음.
>
> 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 & 보수, 통신과 보수

#### 2.3.3.1 Process Control

- 실행 중인 프로그램은 수행을 정상적으로(end()) 또는 비정상적으로(abort()) 멈출 수 있어야 한다. 만약 현재 실행 중인 프로그램을 비정상으로 중지하기 위해 시스템 호출이 행해지거나 또는, 프로그램에 문제가 발행해 오류 트랩(trap)을 유발할 경우, 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다. 이 덤프는 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다. 정상적인건 비정상적이건 운영체제는 명령 해석기로 제어를 전달해야 한다. 명령 해석기는 이어 다음 명령을 읽는다.
- 한 프로그램을 실행하고 있는 프로세스나 잡(job)이 다른 프로그매을 적재(load())하고 실행(execute())하기를 원할 수 있다. 이 기능은 명령 해석기가 사용자 명령, 마우스의 클릭 혹은 일괄처리 명령 등을 통하여 지시된 프로그램을 실행하는 것을 허용한다.

#### 2.3.3.2 File Management

- 생성, 삭제, 열고, 읽고, 쓰고, 변경, 속성획득, 속성 설정, 이동, 복사

#### 2.3.3.3 Device Management

- 프로세스는 작업을 계속 수행하기 위해 추가 자원을 필요로 할 수 있다. 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에의 접근 등이 될 수 있다. 만약 자원들을 사용할 수 있다면, 이들 자원이 주어지고, 제어가 사용자 프로그램으로 복귀될 수 있다. 그렇지 않으면, 프로그램은 충분한 자원이 사용 가능하게 될 때까지 기다려야 한다.

#### 2.3.3.4 Information Maintenance

- 단순히 사용자 프로그램과 운영체제간의 정보 전달을 위해 존재한다.
- 현재 시간, 날짜, 현재 사용자 수, 운영체제의 버전 번호, 자유 메모리 자유디스크 공간 등... 시스템에 관한 정보

#### 2.3.3.5 Communication

- 메시지 전달 모델 - 통신하는 두 프로세스가 정보를 굥환하기 위하여 서로 메시지를 주고 받는다. 상대 통신자가 동일한 CPU에 있는 프로세스든지 또는 통신 네트워크에 의해 연결된 다른 컴퓨터에 있는 프로세스든지 간에 그 이름을 반드시 알고 있어야 한다.
- 마찬가지로, 각 프로세스는 프로세스 이름을 가지고 있으며, 이 이름은 운영체제에 의해 동등한 식별자로 변환되고, 이 식별자는 운영체제가 그 프로세스를 가리키는 데 사용할 수 있다.
- 공유 메모리 모델 - 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 다양한 시스템 호출을 사용한다.
- 정상적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리를 접근하는 것을 막으려고 한다는 것을 기억해야한다.
- 공유 메모리는 두개 이상의 프로세스가 이러한 제한을 제거하는데 동의할 것을 필요로 한다. 그런 후, 이들 프로세스들은 이러한 공유 영역에서 데이터를 읽고 씀으로써 정보 교환을 할 수 있다.

#### 2.3.3.6 Protection

- 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다.



## 2.4 System Services(System Programs)

> 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 보다 편리한 환경을 제공한다.

- 파일 관리 : 이들 프로그램은 파일과 디렉터리를 생성, 삭제, 복사, 개명(rename), 인쇄, 덤프, 리스트하고 그리고 일반적으로 조작한다.
- 상태 정보 : 정보를 단말기나 다른 출력 장치 혹은 파일로 포맷하여 인쇄하거나 또는 GUI의 윈도우에 표시한다. 몇몇 시스템은 환경 설정 정보를 저장하고 검색할 수 있는 등록(registry) 기능을 지원하기도 한다.
- 파일 변경 : 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 다수의 문장 편집기(text editor)가 사용 가능하다.
- 프로그래밍언어지원 : 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해서기가 종종 운영체제와 함께 사용자에게 제공되거나 별도로 다운받을 수 있다.
- 프로그램 적재와 수행 : 일단 프로그램이 어셈블되거나 컴파일된 후, 그것이 수행되려면 반드시 메모리에 적재되어야 한다.
- 통신 : 프로그램은 프로세스, 사용자, 그리고 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공
- 백그라운드 서비스 : 모든 범용 시스템은 부팅할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 가지고 있다.

## 2.5 Linkers and Loaders

- Source files들은 물리적 저장 공간에서 적재되도록 디자인된  오브젝트 파일(코드와 데이터를 포함 하고 있는 relocatable object file)로 컴파일된다.
- Linker는 single binary executable file로 결합된다(바뀐다).
- CPU core에서 작동 시킬 수 있는 메모리에 binary executable file을 적재 한다.
- 이제 이 파일을 읽고 동적 연결된 라이브러리에서 확인을 해서 함수를 실행하며 프로그램을 작동

### *용어 정리

------------------------------

gui : 메뉴와 같이 명령을 시각화, point화 하여 간단하고 편하다는 장점이 있다.

shared memory : 같은 메모리의 부분을 2개 이상의 프로세스를 읽고 쓰는 방식

message passing : OS의 프로세스들의 사이에 이전의 정형화된 정보의 패킷을 통해 의사소통하는 방식

Kernel : 컴퓨터의 운영체제의 핵심이 되는 컴퓨터 프로그램의 하나로, 시스템의 모든 것을 통제한다. 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공한다.

- 보안 : 커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.
- 자원 관리 : 한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원할하게 한다. 특히 프로세스에 처리기를 할당하는 것을 스케줄링이라고 한다.
- 추상화 : 보이지 않는 부분을 추상화 할 수 있도록 도와준다.