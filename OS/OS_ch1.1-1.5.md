### OS

## Chapter 1. Introduction

운영체제(Operating System)는 컴퓨터의 하드웨어를 관리하고, 응용프로그램(application programs)에 기초를 제공하며 사용자와 하드웨어를 연결해주는 매개체 역할을 한다.

### 챕터 목표

- 컴퓨터 시스템의 일반적인 구조와 충돌, interrupt의 역할 설명
- 다중 프로세서 컴퓨터의 구성요소 설명
- 유저 -> 커널 변화 묘사
- 여러 컴퓨터 환경에서 OS가 어떻게 사용되는지 
- 오픈소스 및 무료 OS 예시



### 1.1 What Operating System Do

- 컴퓨터 시스템
  - 하드웨어 - CPU, 메모리, 입출력장치 -> 컴퓨터 시스템에 기본적인 자원 제공
  - OS -> 하드웨어를 제어, 프로그램과 사용자를 연결
  - 응용프로그램 - 워드, 브라우저 -> 자원을 어떻게 사용할 지 결정
  - 유저
- 운영체제는 프로그램들이 유용한 일을 할 수 있는 환경을 제공한다. 운영체제의 역할은 사용자 관점(User View)과 시스템 관점(System View)으로 나눠볼 수 있다.



#### 1.1.1 User View

OS는 사용자가 자원 사용에 신경쓰지 않고(none paid to resource utilization) 컴퓨터를 쉽게 이용 할 수 있도록 설계되어있다. 



![image-20200718150222379](image-20200718150222379.png)



#### 1.1.2 System View

OS는 자원 할당자(resource allocator)이다. 컴퓨터 시스템은 CPU시간, 메모리 공간, 저장 공간, 입출력 장치 등 다양한 문제를 해결해야 하고, OS는 이러한 문제를 해결하기 위해 자원을 관리한다. 또한 유저 프로그램의 실행을 관리하여 오류나 부적절한 컴퓨터 사용을 막는 제어 프로그램 (control program)이다.



#### 1.1.3 Defining Operating Systems

OS는 커널, 미들웨어 프레임워크, 시스템 프로그램을 포함하는 개념

- 항상 실행되는 프로그램: 커널
  - 커널의 관점에서 두 가지의 프로그램이 있다.
    - 시스템 프로그램: OS와 관련있지만 커널에 속할 필요는 없다.
    - 응용 프로그램: OS와 관련 없는 모든 프로그램
- 미들웨어(현재 모바일 OS를 보면 커널외에 미들웨어가 포함되어있다.)
  - 미들웨어란: 어플 개발자를 위한 추가 서비스를 제공하는 프레임워크





### 1.2 Computer-System Organization

일반적인 컴퓨터 시스템은 하나 이상의 CPU와 여러개의 장치 컨트롤러(device controller)가 공통 버스 (common bus)로 연결되어 있는 형태다. 이 버스는 공유 메모리와 장치들(components)간의 연결을 제공한다.

일반적으로, OS는 장치 컨트롤러에 대한 장치 드라이버(device driver)를 가지고 있으며 이 장치 드라이버는 장치 컨트롤러를 이해하고 있고, 나머지 OS에게 장치에 대한 일관적인 인터페이스를 제공한다.(?)

![image-20200718150253825](image-20200718150253825.png)





#### 1.2.1 Interrupts 

인터럽트(interrupt)를 통해 컨트롤러가 장치 드라이버에게 일이 끝났음을 알려준다.



##### 1.2.1.1 Overview

하드웨어는 시스템 버스(system bus)를 통해 CPU에 신호를 보냄으로써 인터럽트를 발생 시킨다. CPU가 인터럽트 신호를 받으면 하던 일을 멈추고, 실행(execution)을 고정된 위치(fixed location)으로 옮긴다. 고정된 위치는 인터럽트에 대한 서비스 루틴(service routine)이 저장되어 있는 시작 주소(starting address)를 포함하고 있다. 인터럽트 서비스 루틴이 실행되어 처리되고 나면 CPU는 원래 작업으로 돌아온다. 이 시작 주소는 인터럽트 벡터(interrupt vector)에 저장되어 있다.

![image-20200718152245547](image-20200718152245547.png)



#### 



#### 1.2.2 storage structure

CPU는 메모리에서만 명령(instruction)을 가져올 수 있기 때문에, 모든 프로그램은 실행되기 위해서는 먼저 메모리에 로드되어야한다. 메인 메모리는 보통 RAM(Random-Access Memory)이라고 부르며 DRAM(dynamic random-access memory)이라는 반도체 기술에 의해 이행된다. 

컴퓨터를 켜면 부트스트랩 프로그램 (Bootstrap program)이라는 초기화 프로그램이 실행된다. 이 프로그램을 컴퓨터의 ROM(Read-Only Memory)이나 EEPROM(Electrically Erasable Programmable Read-Only Memory)에 저장되어 있으며, 주로 펌웨어(Firmware)라고 불린다. 부트스트랩 프로그램은 시스템을 초기화하고, 부트로더(Boot loader)를 실행한다. (멀티부팅 컴퓨터의 경우 부트로더가 여러 운영체제를 가리키고 있는데, 이 경우엔 어떤 운영체제를 실행할지 선택해야 한다.) 그리고 부트로더는 최종적으로 운영체제를 실행하게 된다.

*폰 노이만 구조 (von Neumann architecture) - 처음에 메모리에서 명령을 가져오고, 명령 레지스터 (instruction register)에 저장한다. 명령이 디코딩 되고, 피연산자를 메모리에서 가져와서 내부 레지스터에 저장한다. 연산이 끝난 후 결과를 다시 메모리에 저장한다.

프로그램과 데이터를 메인 메모리에 저장할 수 없는 이유

- 메인 메모리는 프로그램과 데이터를 저장하기에 매우 작다.
- 휘발성이라서 전원이 없으면 모든 자료가 사라진다.

따라서 대부분의 컴퓨터 시스템은 하드디스크(HDD)나 비휘발성 메모리(NVM)과 같은 보조기억장치(secondary storage)가 있다.

#### 1.2.3 I/O Structure

DMA(direct memory access) - 장치와 메모리를 직접 연결하는 방식으로, 버스가 지원하는 기능. 메모리의 일정 부분은 DMA에 사용될 영역으로 지정되며, DMA를 제어하는 컨트롤러는 DMA 컨트롤러라고 부른다. 참고로 CPU를 거치는 방식은 PIO(Programmed I/O)라고 부른다. 장치의 데이터는 장치 컨트롤러에 의해 직접 메모리에 전달되며, CPU에서는 데이터 이동이 완료되었다는 인터럽트만 한 번 일어난다. 이렇게 하면 결과적으로 CPU가 하는 일이 줄어드니까 성능이 좋아진다.



## 1.3 Computer-System Architecture

#### 1.3.1 Single Processor Systems

과거에는 대부분의 컴퓨터 시스템이 싱글 프로세서(single processor)를 사용했다. 싱글 프로세서란 하나의 프로세싱 코어(processing core)가 있는 CPU한개만 탑제된 프로세서이다. 코어(core)란 명령을 수행하고 데이터를 저장하는 레지스터 역할을 한다. 



#### 1.3.2 Multiprocessor Systems

멀티 프로세서 시스템은 이젠 일반적인 컴퓨터 시스템이 되었다. 멀티 프로세서 컴퓨터는 2개 이상의 프로세서를 가지고 있다. 처음에는 서버 컴퓨터에 처음 적용됐는데, 지금은 모바일 기기도 멀티 프로세서 시스템으로 만들어진다. 

멀티 프로세서의 장점:

- 처리량(Throughput) 증가: 프로세서의 수를 늘리면 짧은 시간에 많은 일을 할 수 있다. 물론 프로세서를 계속 늘린다고 성능이 한없이 좋아지는 것은 아니며, 증가 비율이 1:1인 것도 아니다.

  

가장 흔히 사용되는 멀티프로세서 시스템은 대칭 멀티프로세싱(symmetric multiprocessing, SMP)이다. 

SMP: 각각의 프로세서가 CPU를 가지고 있으며 레지스터와 캐시도 가지고 있다. 하지만 모든 프로세서가 시스템 버스를 통해 메모리를 공유한다. SMP 방식의 장점은 성능 저하 없이 많은 프로세스를 동시에 실행할 수 있다는 점이다.  단점은 CPU가 분리되어있기 때문에 한 CPU에 과부하(overloaded)가 걸리는 동안 다른 CPU는 놀 수도 있다(idle)는 점이다. 이러한 단점은 특정 데이터구조를 사용함으로써 해결할 수 있다.

![image-20200718165953007](image-20200718165953007.png)

최근 CPU 설계 트렌드는 하나의 칩(Chip)에 코어(Cores)를 늘리는 것이다. 이러한 멀티 프로세서 시스템을 멀티코어(Multicore)라고 부른다. 코어는 동일한 성능의 CPU 여러 개를 1개의 칩 속에 집접한 것이라고 보면 된다. 칩 내부의 통신(On-chip communication)이 칩 사이의 통신(Between-chip communication)보다 더 빠르기 때문에 여러 개의 칩에 하나의 코어만 두는 시스템보다 더 효율적이다. 뿐만 아니라 하나의 칩에 여러 코어를 담으면 전력을 더 적게 사용한다

![image-20200718170316501](image-20200718170316501.png)

위 사진은 듀얼 코어 시스템이다. 각 코어는 자신만의 레지스터와 로컬 캐시를 갖는다. (하나의 캐시를 공유하기도 한다.)

![image-20200718170910152](image-20200718170910152.png)

멀티프로세서 시스템에 CPU를 추가하는 것은 연산 능력을 증가시키지만 꼭 그런 것만은 아니다. (1:1 증가가 아니라는 뜻) 너무 많은 CPU를 추가하면 시스템 버스에 병목현상이 생기게 되고 성능이 올라가지 않는다. 다른 접근 방식은 각 CPU에 local 메모리를 제공하는 것이다. (Figure 1.10)  이런 방식을 non-uniform memory access, NUMA라고 한다. 

NUMA의 장점은 CPU가 각자의 local 메모리에 접근하는 속도가 빠르다는 것과, 시스템 인터커넥트에서 경쟁(contention)이 없다는 점이다. (이 부분 이해 안됨) 

단점은 remote 메모리에 접근하는 속도가 느리다는 점이다. 예를들면 CPU1에서 CPU3의 local 메모리에 접근하는 속도는 자신의 메모리에 접근하는 속도보다 훨씬 느리다.

이러한 단점은 OS의 CPU 스케줄링 및 메모리 관리 능력으로 최소화할 수 있다.



#### 1.3.3 clustered system

멀티프로세서 시스템의 일종인 클러스터 시스템(Clustered system)은 여러개의 CPU을 모아 놓은 구조다. 클러스터 시스템은 여러개의 개별 시스템(또는 노드)들이 하나로 모여있다는 점에서 앞서 설명한 멀티프로세서 시스템과는 조금 다르다. 멀티프로세서 시스템은 여러CPU가 하나의 시스템을 이루는 것이지만, 클러스터 시스템은 여러 독립적인 시스템이 모여 하나의 시스템을 이루는 것이다. 이런 시스템을 약결합(Loosely coupled)라고 부르며, 각 노드들은 싱글 프로세서 시스템일수도 있고, 멀티코어 시스템일 수도 있다.

클러스터의 정의가 딱 명확히 정해져 있지는 않다. 단지 클러스터 컴퓨터들이 하나의 저장소를 공유하고, 이를 LAN(Local-Area Network)과 같은 네트워크로 연결한 시스템을 보통 클러스터 시스템이라고 부른다. 클러스터링은 고가용성(High-availability) 서비스를 제공하기 위해 사용되며, 단일 컴퓨터보다 훨씬 저렴하게 비슷한 성능을 낼 수 있다.

클러스터 시스템은 비대칭 클러스터링(Asymmetric clustering)과 대칭 클러스터링(Symmetric clustering)으로 나뉜다. 비대칭 클러스터링에서 하나의 장비는 상시 대기 모드(Hot-standby mode)로 작동하며, 서버를 동작시키고 있는 다른 노드들을 모니터링할 뿐 별도의 작업은 수행하지 않는다. 만약 서버에 문제가 생기면 이 상시 대기 노드가 서버로서 작동하게 된다. 대칭 클러스터링은 두개 이상의 노드가 작업을 수행하는 동시에 다른 노드들을 모니터링하는 구조다. 이러한 구조는 하드웨어의 자원을 최대로 사용할 수 있어 더 효율적이다.

클러스터 시스템은 여러개의 컴퓨터 시스템이 네트워크로 연결되어 있는 구조이기 때문에 고성능 컴퓨팅 환경(High-performance computing environments)을 제공할 수 있다. 다만 단일 시스템에 비해 유지보수가 힘들고, 시스템의 성능이 네트워크 환경에 많은 영향을 받는다는 단점이 있다.



## 1.4 Operating-System Structure

컴퓨터를 실행하거나 재부팅 할때, 부트스트랩 프로그램이라는 초기 프로그램이 필요하다. 이것은 컴퓨터 펌웨어에 저장되어 있으며 CPU 레지스터부터 장비 컨트롤러까지 모든 것을 초기화 한다. 부트스트랩 프로그램은 OS를 로드하고 실행하는 법을 알아야한다. 따라서 부트스트랩 프로그램은 OS 커널을 찾아내서 메모리에 로드해야 한다.

커널이 로드, 실행되면 시스템과 사용자에게 서비스를 제공해야 한다. 이때 일부 서비스는 커널 외부에서 제공되는데, 이들은 부팅할 때 메모리에 로드되는 시스템 프로세스(System processes)나 시스템 데몬(System daemons)이다. Linux의 경우 첫 시스템 프로세스는 `systmd`이며, 이 프로세스는 또 다른 데몬들을 실행시킨다. 데몬은 프로세스로 백그라운드에서 돌면서 시스템 로그는 남기는 등의 여러 작업을 한다. 이러한 과정이 끝나면 시스템이 완전히 부팅되고, 이벤트가 발생하기를 기다리게 된다.

이벤트는 거의 모든 경우에서 인터럽트에 의해 발생한다. 섹션 1.2.1 에서 하드웨어 인터럽트를 다뤘다. 이 외에 소프트웨어가 발생시키는 인터럽트를 trap(또는 예외(exception))이라고 하며 에러(0으로 나누거나 유효하지 않은 메모리 접근)나 시스템 콜(system call)이라고 불리는 유저 프로그램의 특별한 요청에 의해 발생한다.



### 1.4.1 Multiprogramming and Multitasking

OS에서 가장 중요한 것 중 하나는 CPU나 입출력 장치를 계속 사용하는, 다중 프로그램(multiple program) 실행 능력이다. 게다가 사용자들은 하나 이상의 프로그램을 동시에 돌리고 싶어한다. 멀티프로그래밍은 프로그램을 잘 정리하여 CPU가 항상 하나의 프로그램을 실행하게 만들어 CPU 사용률을 높인다. 실행중인 프로그램을 프로세스(process)라 한다.

-> 1챕터에서 다루기 힘든거같습니다.



#### 1.4.2 Dual-mode and Multimode Operation

![image-20200719003105964](image-20200719003105964.png)

운영체제와 사용자는 컴퓨터의 하드웨어, 소프트웨어 자원을 공유하기 때문에 사용자 프로그램이 오류를 일으키지 않도록 방지해야 한다. 운영체제는 사용자 프로그램이 함부로 시스템에 접근하지 못하도록 모드(Modes)를 나눠둔다. 유저 모드(User mode)와 커널 모드(Kernel mode, also called supervisor mode, system mode, privileged mode)가 그것이며, 하드웨어의 모드 비트(Mode bit)가 `0`은 커널 모드, `1`은 유저 모드임을 가리킨다. 이러한 이중 모드(Dual-mode) 방식을 사용하면 나쁜 의도를 가진 사용자로부터 운영체제, 하드웨어를 비롯한 시스템과 사용자를 보호할 수 있다. 하드웨어는 커널 모드일 때만 특권 명령(Privileged instructions)를 실행한다. 만약 유저 모드에서 특권 명령을 실행하려 한다면 하드웨어는 이 동작을 막고 운영체제에게 트랩을 보낼 것이다. 유저 모드에서 합법적으로(?) 커널 모드의 기능을 호출하고 싶다면 시스템 콜(System call)이라는 인터페이스를 통해야 한다.



### 1.4.3 Timer

운영체제는 사용자의 프로그램이 제어권을 운영체제에게 넘겨주지 않는 상황(무한루프에 빠지거나 시스템 서비스스 실패)을 방지하기 위해 타이머(Timer)를 사용한다. 타이머는 운영체제에게 제어권을 보장하기 위해 특정 주기에 인터럽트를 발생시킨다. 운영체제는 카운터를 설정하고, 타이머의 시간은 매 틱(Ticks)마다 감소한다. 그렇게 카운터가 0에 도달하면 인터럽트가 발생한다.



## 1.5 Resource Management

### 1.5.1 Process Management

디스크에 있으면 프로그램, 메모리에 로드되면 프로세스다. 프로그램은 하나지만 프로세스는 여러 개일 수 있다. 강조할 점은, 프로그램은 디스크에 저장되어 있는 수동적(Passive) 존재인 반면 프로세스는 능동적(Active) 존재다. 프로그램은 하나지만 프로세스는 여러 개일 수 있다. 또한 프로세스는 프로그램이 어디까지 실행되었는지 북마크하는 프로그램 카운터(Program counter)를 가지고 있다. 싱글쓰레드(Single-thread) 프로세스는 하나의 프로그램 카운터를 가지고 있으며, 멀티쓰레드(Multi-threads) 프로세스는 여러개의 프로그램 카운터를 가지고 있다.

운영체제는 프로세스 관리를 위해 CPU에게 프로세스와 쓰레드를 스케줄링하고, 프로세스를 생성하거나 제거하는 활동을 한다. 뿐만 아니라 일시정지하거나 재실행하고, 프로세스의 동기화(Synchronization)와 통신도 제공한다.



- 사용자 프로세스와 시스템 프로세스를 생성 및 삭제한다
- CPU의 프로세스와 쓰레드 스케쥴링
- 프로세스 일시정지 및 재실행
- 프로세스 동기화 메커니즘 제공
- 프로세스 통신 메커니즘 제공

### 1.5.2 Memory Management

메인 메모리는 현대 컴퓨터 시스템의 핵심이며, 방대한 바이트의 배열이다. 그리고 각 바이트는 그들만의 주소를 가지고 있다. 이후 프로그램이 실행될 때 프로그램은 절대 주소(Abolute addresses)로 매핑(Mapping)되어 메모리에 로드된다. 메모리 관리는 여러 요인을 고려해야 하는 작업이며, 특히 시스템의 하드웨어 설계를 신경써야 한다.

운영체제는 메모리 관리를 위해 메모리의 어떤 부분이 어디에 쓰이는지, 누가 사용하는지 추적하고, 어떤 프로세스와 데이터가 메모리의 안팎으로 옮겨질지 결정한다. 또한 메모리 공간을 할당하고 해제하는 것도 운영체제가 하는 일이다.



- 메모리의 어떤 부분이 현재 사용중인지, 어떤 프로세스가 이용하고 있는지 추적
- 메모리 영역을 할당 및 해제
- 어떤 프로세스와 데이터가 메모리 안팎으로 옮겨질지 결정



### 1.5.3 File-System Management

파일 관리는 운영체제가 하는 일 중 가장 눈에 잘 보이는 요소다. 운영체제는파일을 생성, 제거하며, 당연히 읽기, 쓰기도 한다.



- 파일 생성 및 제거
- 디렉토리 생성 및 제거
- primitives? 지원하여 파일과 디렉토리 수정
- mass storage에 파일 매핑
- 백업





### 1.5.4 Mass-Storage Management

대부분의 프로그램이 메모리에 로드 되기 전에 보조 기억장치에 저장되어 있다. 따라서 보조기억장치에 대한 적절한 관리는 필수적이다.



- 장착 및 해제
- 빈 공간 관리
- 공간 할당
- 디스크 스케쥴링
- 파티셔닝
- 보호



### 1.5.5 Cache Management

![image-20200719005513060](image-20200719005513060.png)

캐싱(Caching)은 컴퓨터 시스템에서 정말 중요한 부분이다. 캐싱의 원리는 다음과 같다. 정보는 메인 메모리같은 저장 장치에 들어있다가 사용될 때 캐시라는 더 빠른 저장 장치로 복사된다. 정보가 필요할 때 제일 먼저 캐시에 있는지 확인하고 없으면 소스에 있는지 확인하고 캐시로 옮긴다.





### 1.5.6 I/O System Management

운영체제는 모든 입출력장치를 파일로 취급한다. 오직 장치드라이버(Device driver)만이 장치의 자세한 정보를 알고 있다.





















































































