# Ch 3.3 - 3.4

## 3.3 Operations on Processes

#### 3.3.1 프로세스 생성 (Process Creation)

- 하나의 프로세스가 실행되는 중간에 새로운 프로세스들을 생성하는 경우가 있는데, 이 경우에 새로운 프로세스들를 생성하는 프로세스는 **부모 프로세스(parent process)**, 생성된 새로운 프로세스들은 **자식 프로세스(children processes)**라고 불린다. 생성된 자식 프로세스들 역시도 자신들의 자식 프로세스를 생성할 수 있으며, 결국에는 프로세스들로 이루어진 **트리 구조**가 형성된다.

- 운영체제들은 각각의 프로세스들을 **unique한 process identifier(pid)**로 구분을 한다.

- 각 운영체제에서의 **root parent process**

  - **UNIX 운영체제**에서는 가장 root parent process가 **init (System V init)**이며, 이 프로세스의 pid는 항상 1이다. 
  - **Linux 운영체제**에서는 가장 root parent process가 **systemd** 프로세스이며, 이 프로세스의 pid는 항상 1이다. UNIX에서의 **init**보다 훨씬 더 유연하고 더 많은 서비스를 제공해준다.

  

- 자식 프로세스가 생성이 되면 프로세스 실행을 위한 자원들이 요구되는데, 이 경우에는 **1) 운영체제가 자원들을 분배해주는 방법**과 **2) 부모 프로세스가 가진 자원들의 일부를 받는 방법**이 있다.

  - 부모의 자원의 일부를 물려받거나 같이 사용하는 방법은 자식 프로세스를 너무 많이 만들어서 시스템을 overload하는 것을 막을 수 있다
  - 이외에도 the parent process may pass along initialization data(input) to the child process.

  

- 프로세스가 새로운 자식 프로세스를 생성했을 때 생길 수 있는 시나리오

  - 부모 프로세스와 자식 프로세스가 **동시에 실행(concurrency)**
  - 부모 프로세스가 자식이 실행을 **종료 할 때까지 기다림**

  

- 자식 프로세스가 생성되었을 때 생길 수 있는 address-space의 형태

  - 자식 프로세스가 부모 프로세스의 중복인 경우 (자식이 부모와 같은 프로그램과 데이터를 가지는 경우)
  - 자식 프로세스에 새로운 프로그램이 적재되는 경우



#### 프로세스 생성에서의 UNIX vs Windows

- UNIX 운영체제
  - 새로운 프로세스를 **fork()**라는 시스템 호출(system call)을 이용해서 생성하며, 새로운 자식 프로세스는 **부모 프로세스의 주소 공간(address space)**를 가지고 있다.
  - 생성 후 부모와 자식 프로세스는 동시(concurrency)에 실행되지만, **fork()의 return code**가 자식 프로세스에게는 zero인 반면, 부모 프로세스에게는 자식 프로세스의 pid이다.
  - fork()가 호출된 후, 부모와 자식 프로세스 중 하나가 **exec()** 시스템 호출을 하며, 이를 통해 exec()을 호출한 프로세스의 메모리 공간은 새로운 프로그램으로 대체된다.
  - 부모는 자식 프로세스를 생성한 후 **wait()** 시스템 호출을 이용해서 자식 프로세스가 끝날 때까지 기다리다가 실행을 재개할 수도 있다.

- Windows 운영체제
  - 새로운 프로세스를 **CreateProcess()** 함수를 이용해서 생성하며, UNIX에서의 fork()와는 달리 생성되는 자식 프로세스의 주소 공간에 특정 프로그램이 적재된다. 또한 파라미터도 여러개 넘겨줘야 한다. 
  - 윈도우에서의 wait()은 **WaitForSingleObject()**이다.



#### 3.3.2 프로세스 종료 (Process Termination)

- 프로세스는 할일을 다 끝내고 **exit()** 시스템 호출을 했을 때 종료된다. 이때, 종료된 프로세스는 기다리고 있는 부모 프로세스에게 **status value** 를 리턴 할 수도 있다. 종료된 프로세스의 모든 자원들은 운영체제가 다시 회수한다.



- 프로세스가 종료되는 경우

  - 할일을 다 끝내고 exit()을 호출했을 때 (보통의 경우)
  - 유저 또는 오작동하는 어플리케이션이 다른 유저의 프로세스들을 종료시켜 버릴 때
  - 다른 프로세스에 의해 종료될 때. 이때는 보통 부모 프로세스에 의해서 종료되는 경우인데, 부모가 자식 프로세스를 종료 시키는 경우들은 다음과 같다. 
    - 자식 프로세스가 배분 받은 자원들보다 더 많은 자원들을 잡아 먹을 때
    - 자식 프로세스에게 주어진 task가 더이상 필요하지 않을 때
    - 부모 프로세스가 종료된 상태에서 자식 프로세스가 실행되지 못하게끔 되어있는 운영체제에서 부모 프로세스가 종료될 때. 부모 프로세스가 종료되어서 자식 프로세스들도 모두 종료되는 현상을 **cascading termination**이라고 부른다. 

- **wait()**

  - 부모 프로세스가 자식 프로세스가 종료될 때까지 기다리고 싶은 경우, **wait()** 시스템 호출을 사용할 수 있다.
  - 이 시스템 호출은 부모 프로세스가 어떤 자식 프로세스가 종료되었는지 알 수 있게끔 종료된 자식 프로세스의 pid를 리턴해준다.

- 하나의 프로세스가 종료되어도 그 부모 프로세스가 wait()을 호출 할 때까지는 process table에 남아있어야하는데, 이는 process table이 해당 프로세스의 exit status를 가지고 있기 때문이다. 이렇게 실행은 종료되었지만 아직 부모 프로세스가 wait() 호출을 안해서 process table에 남아있는 프로세스들을 **zombie process**라고 부른다.

  - 만약 부모 프로세스가 wait()을 호출하지 않은채로 종료되면, 자식 프로세스들은 **orphan**들로 남는다.

    - **UNIX**에서는 이 경우에 init 프로세스를 해당 자식 프로세스들의 새로운 부모로 할당한다.
    - **Linux**에서는 systemd뿐만 아니라 그 어떠한 프로세스도 해당 자식 프로세스들의 새로운 부모가 될 수 있다.

    

##### 3.3.2.1 Android Process Hierarchy

- 모바일 환경에서는 자원의 제한이 있기 때문에 자원 부족으로 인해 현재 있는 프로세스들 중 몇개를 종료시켜야 할 때 **프로세스들의 우선순위**를 정해서 가장 덜 중요한 프로세스부터 종료시킨다.





## 3.4 프로세스 간 통신 (Interprocess Communication)

- independent process vs cooperating process (queue에 있는 프로세스들끼리)
  - independent process: 실행되고 있는 다른 프로세스들과 데이터를 공유하지 않는 프로세스
  - cooperating process: 다른 프로세스들과 데이터를 공유하며 실행되고 있는 다른 프로세스들에 의해 영향을 받거나 다른 프로세스들에게 영향을 줄 수 있는 프로세스
- process cooperation을 허용하는 이유
  - 정보 공유: 프로세스들이 같은 정보를 필요로 하는 경우  ex) 복붙
  - 빠른 연산: 특정 작업을 더 빠르게 끝내고 싶은 경우, 그 작업을 여러개의 subtask들로 나눌 수 있으며 이럴 때 cooperation이 필요 (물론 이를 위해서는 multi-core가 전제되어야함)
  - 모듈화: 시스템을 모듈화하기 위해

- process cooperation을 위해서는 프로세스 간 정보교환을 가능하게 해주는 **interprocess communication(IPC)** 매커니즘이 필요하다. IPC에는 두 개의 모델이 있다.

  - **shared-memory model**
    - 협력하는 프로세스들 모두가 접근할 수 있는 공유 메모리가 생긴다.
    - message-passing model보다 더 빠르다.
    - 하지만 보통 read만 가능할뿐, 수정은 함부로 못함
  - **message-passing model**
    - 협력하는 프로세스들 간 통신이 메세지 교환으로 이루어진다.
    - 작은 양의 데이터를 주고받는데에 좋다.
    - 분산 시스템에서 구현하기에 더 적합하다.

  