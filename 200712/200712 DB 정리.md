# DB 정리

김정원

## 데이터베이스

### 데이터베이스의 정의

-  1) 통합된 데이터(Integrated data), 2)저장된 데이터(Stored data), 3) 운영 데이터(Operational Data), 4) 공용 데이터(Shared data)
-  즉 어느 한 조직의 업무를 수행하는데 존재가치가 확실한, 여러 응용시스템이 공동으로 소유하고 유지하며 컴퓨터가 접근할 수 있는 저장매체에 저장된 중복을 배제한 데이터의 모임. 

### 데이터베이스의 특징

1) 실시간 접근성 : 수시적이고 비정형적인 질의에 대하여 실시간 처리 응답이 가능해야 한다.

2) 계속적인 변화 : 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다 

3) 동시 공용 : 여러 사용자가 동시에 자기가 원하는 데이터를 이용할 수 있어야 한다. 

4) 내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 대 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 내용으로 데이터를 찾는다. 





## DBMS

### DBMS

DBMS는 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성하고 데이터를 관리해주는 소프트웨어입니다.

### DBMS의 장점

- 데이터베이스의 중복을 최소화
- 데이터 공유
- 쉬운 유지
- 시간 절약
- 백업 용이
- 유저 인터페이스에 독립적일 수 있다. 

### RDBMS

관계형(Relational) 데이터베이스 시스템

- 테이블- 컬럼 형태의 데이터 저장 방식
- 테이블 - 테이블 간의 연관관계(주로 외래키형태)를 이용해 필요한 정보를 구하는 방식
- 모델링은 E-R(Entity Relationship) 모델을 사용
- Terminology
  - 스키마 : DB, 테이블 정의 내역
  - SQL 쿼리 : 관계형 DBMS를 사용하는 전용 질의언어
  - 기본키 : 테이블에서 하나의 레코르를 지정할 수 있는 하나 이상의 컬럼 집합
  - 외래키 : 외부 테이블을 참조하는 키
  - 테이블 : 정보들의 묶음 단위
  - 컬럼 : 테이블을 구성하는 정보들
  - 레코드 : 테이블에 들어있는 여러가지 인스턴스 하나하나를 지정
  - 도메인값 : 각 컬럼에서 나올 수 있는 후보값

### NoSQL

비관계형 데이터베이스 시스템.

- 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터 베이스
- 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용한다. 
- join 처리가 없기 때문에 스케일 아웃을 통해 노드 확장이 용이하고 데이터 유연성이 높다.
- 복잡한 쿼리가 불가능하고 일관성을 보장할 수 없다. 







## 데이터베이스 설계

### 설계 단계

1. 현실세계 - 요구사항 수집 분석
2. 개념적 설계 
   - ER 다이어그램을 통해 요구사항을 개념적으로 표현
3. 논리적 설계
   - Relation model 을 통해 개념적 설계를 논리적으로 표현
4. 물리적 설계 
   - 실제 디스크와 같은 물리 저장장치에 데이터를 저장할 수 있도록 표현

1 - 3번까지는 특정 DBMS에 관계가 없지만 물리적 설계는 특정 DBMS를 전제로 한 모델링이기 때문에 DBMS에 의존적

### ER 다이어그램

출처 : https://victorydntmd.tistory.com/126?category=687930

ER 모델은 요구사항으로부터 얻어낸 정보들을 개체(Entity), 애트리뷰트(Attribute), 관계성(Relation)으로 기술하는 데이터 모델을 말합니다.

![img](https://t1.daumcdn.net/cfile/tistory/999CD9505A77ADD210)



- **개체( Entity )**

- - 개체란 단독으로 존재하는 객체를 의미하며, 동일한 객체는 존재하지 않습니다.

  - - 예를 들어, 학생 정보가 학번, 이름, 학년이 있을 때, 3개의 정보가 모두 같은 학생이 오직 한 명이면 이를 개체라고 합니다.
    - 즉, 학생 한명이 개체가 되는 것입니다.

  - 이 개체들의 집합을 **Entity Type**이라고 합니다. 여기서는 Student, Course가 되겠네요.

- - ER 다이어그램에서 Entity Type은 네모로 표현합니다.

- **애트리뷰트, 속성( Attribute )**

- - 개체가 갖는 속성을 의미합니다.

  - - 예를 들어, Student에서 학번, 이름, 학년 같은 정보를 속성이라 합니다.

  - ER 다이어그램에서 Attribute는 원으로 표현합니다.

- **관계 ( Relation )**

- - Entity Type간의 관계를 의미합니다.

  - - 예를 들어, 수강을 뜻하는 Takes는 학생과 과목간의 "수강"이라는 관계를 갖습니다.
    - 이 때 Takes를 **Relation Type**이라 하며, Relation Type 역시 속성을 가질 수 있습니다.

  - ER 다이어그램에서 Relation은 마름모로 표현합니다.



ER 다이어그램을 구성하는 요소는 위와 같습니다.



**2. 애트리뷰트 ( Attribute )**

**1) Attribute Domain**

- 해당 Attribute가 가질수 있는 집합(도메인)을 말합니다.

- 예를 들어,

- - 학생의 학년을 뜻하는 year 애트리뷰트는 1,2,3,4 와 같은 숫자만 허용하므로 year의 Attribute Domain은 정수형(integer)입니다.
  - 학생의 이름을 뜻하는 name 애트리뷰트는 문자열이여야 하므로 name의 Attribute Domain은 문자열(String)입니다.



**2) 키 애트리뷰트 ( Key Attribute )**

- 다른 객체들과 중복되지 않는 고유한 값을 가진 Attribute로서, 주로 객체를 식별하는데 사용되는 Attribute입니다.

- 예를 들어, 학생의 학번을 의미하는 Student_no는 다른 학생들과 중복되지 않는 고유한 번호입니다.

- - 따라서 Student_no는 Key Attribute 입니다.

- Key Attribute를 ER 다이어그램에서는 원에 밑줄로 표시합니다.

![img](https://t1.daumcdn.net/cfile/tistory/991CBE385A77C77713)





**3) 복합 애트리뷰트 ( Composite Attribute )**

- 독립적인 Attribute들이 모여서 생성된 Attribute를 의미합니다.

- 예를 들어, 학생의 주소를 나타내는 Address 애트리뷰트가 있을 때, 우리나라에서 주소는 "경기도", "OO시", "OO동", "OO아파트"와 같이 표현합니다.

- - 즉 Address는 위의 4개의 독립된 Attribute가 모여서 생성된 Attribute이므로 Address를 Composite Attribute라고 합니다.

![img](https://t1.daumcdn.net/cfile/tistory/99E1A9355A77B14518)



**4) 다중값 애트리뷰트 ( Multi-Valued Attribute )**

- 하나의 Attribute가 여러 개의 값을 가지는 Attribute를 의미합니다.
- 예를 들어, 학생의 전공을 나타내는 Degree Attribute가 있다고 있을 때, 이 학생이 복수 전공을 할 경우 Degree Attribute 값이 2개가 되므로, 이 때 Degree Attribute를 Multi-Valued Attribute라고 합니다.
- 이와 달리, 오직 하나의 값을 갖는 애트리뷰트를 **단일값 애트리뷰트**(Single-Valued Attribute)라고 합니다.
- Multi-Valued Attribute는 ER 다이어그램에서 두 개의 원으로 표현합니다.

​      ![img](https://t1.daumcdn.net/cfile/tistory/99E7163C5A77C7EF37)





**5) 유도된 애트리뷰트 ( Derived Attribute )**

- 다른 Attribute가 갖고 있는 값으로부터 계산되어져 나온 Attribute를 의미합니다.

- 예를 들어, 모든 상품의 총 가격을 나타내는 total, 상품의 가격을 나타내는 price, 상품의 개수를 나타내는 count Attribute가 있다고 가정하겠습니다. 

- - total은 price와 count의 곱으로 계산되어져 나오는 값이므로 total Attribute는 Derived Attribute입니다.

- Derived Attribute는 ER 다이어그램에서 원을 점선으로 표현합니다.

​       ![img](https://t1.daumcdn.net/cfile/tistory/99822A355A77C8260F)



**3. 관계성 ( Relationship )**

ER 다이어그램을 설계하는 가장 큰 목적은 Entity Type을 정의하고 Entity Type간의 관계를 표현하는 것입니다.

Attribute를 통해 Entity Type을 정의했다면, **Relationship**을 통해 Entity Type간의 관계를 표현 표현합니다.



관계성은 2가지 제약조건을 명시함으로써 표현할 수 있습니다.



**1) 카디널리티 비율 제약조건 ( Cardinality Ratio Constraint )**

관계를 맺는 두 Entity Type에 대해, 한 개체가 얼마나 많은 다른 개체와 관련될 수 있는지를 나타내는 제약조건을 뜻합니다.

- **일대일(1 : 1)**

- - **두 개 Entity Type의 개체들은 서로 일대일로 대응**

- **일대다(1 : N)**

- - **하나의 개체가 다른 Entity Type의 많은 개체들과 관련되지만, 그 역은 성립하지 않음**

- **다대다(N : M)**

- - 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되며, 역이 성립



예를 들어, "학사 관리 시스템"에서 한 학생은 많은 과목을 수강할 수 있고 한 과목에는 많은 학생이 수강하므로, Student Entity Type과 Course Entity Type은 N : M 관계입니다.

이러한 카디널리티 비율제약조건을 ER 모델에 표현하면 다음과 같이 N, M을 명시해줘서 표현합니다.

![img](https://t1.daumcdn.net/cfile/tistory/994F233A5A77BBDC10)



또 다른 예시로, 부모와 자식 Entity Type 관계에서 부모는 많은 자식을 가질 수 있지만 자식은 한 부모만 가질 수 있습니다.

즉, 부모와 자식은 1 : M 관계이며, 이를 ER 다이어그램으로 다음과 같이 표현할 수 있습니다.

간혹 1과 M을 어느 선에 명시해야 할지 헷갈리는 경우가 있는데, M에 해당하는 Entity Type에 M을 명시해주면 됩니다.

![img](https://t1.daumcdn.net/cfile/tistory/990FBF485A77BE421D)



**2) 참여 제약조건 ( Participation Constraint )**

관계를 맺는 두 Entity Type에 대해 한 개체의 존재가 다른 개체의 존재에 의존하는지 여부를 나타내는 제약조건을 뜻합니다.

- **전체 참여 ( Total Participation )**

- - 하나 또는 그 이상의 개체가 참여

- **부분 참여 ( Partial Participation )**

- - 선택적인 참여



에를 들어, 학생은 과목을 꼭 수강 할 필요가 없지만 과목은 항상 수강생이 있어야 합니다.

수강생이 없는 과목은 폐강되기 때문이죠.



ER 모델에서 전체 참여는 두 개의 실선으로 부분 참여는 한 개의 실선으로 표현하고, 이를 표현하면 다음과 같습니다.

![img](https://t1.daumcdn.net/cfile/tistory/9985DE3C5A77BC6A15)







**3) 구조적 제약조건 ( Structural Constraint )**

앞서 살펴 본 두 개의 제약조건을 가리켜 구조적 제약조건이라 합니다.

구조적 제약조건은 관계를 맺는 두 Entity Type에 1 , N , M을 표시하거나 한 줄 또는 두 줄을 표시하지 말고 **( MIN, MAX ) 방식**으로 두 제약조건을 한 번에 표현하는 방식입니다.



예를 들어, 학생은 최소 3개, 최대 6개의 강의를 수강할 수 있으며, 강의는 최소 10명 최대 100명의 학생들이 들을 수 있을 때, 이를 ER 다이어그램으로 표현하면 다음과 같습니다.

![img](https://t1.daumcdn.net/cfile/tistory/99DA864F5A77CFEC25)







지금까지 여러 애트리뷰트와 관계성의 두 가지 제약조건의 개념, 그리고 이를 ER 다이어그램에서 어떻게 표현하는지에 대해 알아보았습니다.

이 내용들을 정리하면 아래 그림과 같습니다.



![img](https://t1.daumcdn.net/cfile/tistory/99766E365A77C87A1A)





**4. 약한 개체( Weak Entity )와 식별 관계성 타입(Identifying Relationship Type)**

약한 개체란 자신의 Key Attribute가 없는 Entity Type을 뜻합니다.



예를 들어 "학사 관리 시스템"에서 강의번호 10043는 10043-01 , 10043-02와 같이 여러 개의 분반이 있을 수 있습니다.

이 때 분반이라는 개체는 자신의 key Attribute가 없고, 강의 테이블에 의존하기 때문에 **약한 개체**라 합니다.

다시 말하면 분반이 존재하기 위해서는 꼭 Course Entity Type이 있어야 합니다.



강의와 분반의 관계를 ER 다이어그램으로 표현하면 다음과 같습니다.

![img](https://t1.daumcdn.net/cfile/tistory/996B0B485A77CEA52A)



ER 다이어그램에서 약한 개체는 두 개의 네모로 표현하고, 약한 개체의 key인 bun_no를 **partial key**( 부분 키 )라고 합니다.

부분 키는 단독으로 존재할 수 없고 자신을 소유하고 있는 Owner Entity Type인 Course Entity type의 key와 합쳐서 표현되어야 합니다.

ER 다이어그램에서 부분 키는 점선으로 된 밑줄로 표현합니다.



또한 Entity type이 약한 개체와 관계를 맺을 때는 **식별 관계성 타입**으로 표현하고, ER 다이어그램에서 두 개의 마름모로 표현합니다.

약한 개체는 항상 의존적이기 때문에 참여 제약 조건은 **전체 참여**( total participation )입니다.



### 관계 모델 (Relation Model)


관계 모델은 관계형 데이터베이스에 직접 구현할 수 있도록 DB구조를 정의하는 방법을 제공합니다.

쉽게 테이블을 설계하는 과정이라고 생각하시면 되고, ER 다이어그램을 기반으로 작업하는 것이 순서입니다.



**관계 모델은 릴레이션의 관계를 표현**하는 것입니다.

아래는 관계 모델의 핵심인 릴레이션에 대한 예시입니다.

![img](https://t1.daumcdn.net/cfile/tistory/99F23C505A77D5700B)

- **릴레이션 ( Relation )**

- - 개체를 표현하기 위한 데이터 구조로써 2차원 테이블로 표현하며, heading(스키마)와 body(본체)로 구성되어 있습니다.

  - - heading은 속성(attribute)이 n개가 모인 집합이며, 이름과 데이터형으로 구성되어 있습니다.
    - body는 속성값의 집합인 튜플(tuple)의 집합입니다.

  - SQL의 테이블과 대응됩니다.

- **튜플 ( Tuples )**

- - 하나의 개체를 의미하고 Relation에서 행으로 표현하며, 이를 릴레이션 상태( Relation State )라고도 합니다.

  - 

    각 튜플은 유일해야 한다는 특징이 있습니다.

  - SQL의 row와 대응됩니다.

- **애트리뷰트 ( Attributes )**

- - 개체의 속성들을 의미하며 Relation에서 열로 표현
  - SQL의 column과 대응됩니다.

이를 정리하면, 릴레이션은 튜플의 모임이고, 릴레이션의 관계를 정의한 것이 관계 모델입니다.

관계 모델은 릴레이션 단위로 다양한 연산을 사용해 질의를 수행하는 데이터 모델입니다.









**2. 제약 조건**

관계 모델이 정의되기 위해서는 몇 가지의 제약 조건이 있습니다.



**1) 무결성 제약 조건 ( Integrity constraints )**

한 객체에 저장되는 데이터를 제한하는 조건을 말합니다.

- **도메인 제약 조건**

- - 각 튜플의 애트리뷰트는 도메인에 속하는 값이어야 합니다. 
  - 즉, 도메인이 Integer면 Integer 값만 저장될 수 있습니다.

- **엔티티 무결성 제약 조건**

- - 기본 키 값은 NULL이 될 수 없습니다.

- ***\*참조 무결성 제약 조건\****

- - 어떤 릴레이션 A의 튜플이 다른 릴레이션 B의 튜플을 참조하려면, 참조하려는 그 튜플은 B 릴레이션 내에 존재해야 합니다.

  - 참조되는 테이블의 행을 이를 참조하는 참조키가 존재하는 한 삭제될 수 없고, 기본키도 변경될 수 없다. 

  - 외래 키(Foreign key)는 참조 무결성 제약조건을 만족해야 합니다.

    외래 키 : 다른 릴레이션의 key 애트리뷰트를 참조하는 애트리뷰트

  - 참조 무결성의 설정 조건 

    1) 기본 테이블에서 사용한 필드는 기본키이거나 고유 인덱스가 설정되어 있어야 한다.

    2) 기본 테이블과 관계 테이블 둘 다 테이블이어야 한다. 

    3) 관계를 설정하는 테이블은 형식이 같아야 한다. 



**2) 키 제약 조건**

서로 다른 튜플은 동일한 키 애트리뷰트를 갖지 않아야 한다는 조건을 말합니다.



## 정규화

관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화라고 한다. 데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다. 일반적으로 정규화란 크고, 제대로 조직되지 않은 테이블들과 관계들을 작고 잘 조직된 테이블과 관계들로 나누는 것을 포함한다. 정규화의 목적은 하나의 테이블에서의 데이터의 삽입, 삭제, 변경이 정의된 관계들로 인하여 데이터베이스의 나머지 부분들로 전파되게 하는 것이다.

### 제 1 정규형

1NF를 만족하기 위한 조건은 "릴레이션이어야 한다."는 것이다.

테이블과 릴레이션은 비슷하지만 다른 개념인데, 다음의 과정을 통해 테이블은 릴레이션과 같아집니다.

- 테이블에는 컬럼이나 행에 순서가 존재하지만, 릴레이션에는 순서가 존재하기 때문에 순서를 고려하지 않습니다.

- 중복되는 튜플이 존재하지 않음

- 구체적인 값을 가져야 합니다. 즉 값으로 NULL을 갖지 않습니다.

- 값은 의미가 있는 한 묶음의 데이터, 즉 원자 단위여야 합니다. ( **원자성** )

- - 원자 단위이려면, 각 행마다 한 컬럼에 하나의 값을 가져야 합니다.
  - 예를 들어, 주소라는 컬럼에 "시, 도, 군, 상세주소"를 몽땅 저장하는 것은 바람직하지 않습니다.

![img](https://t1.daumcdn.net/cfile/tistory/99D586345CCD283916)





### 제 2 정규형

2NF는 후보키의 진부분집합에서 키가 아닌 속성에 대해, **부분 함수 종속성을 제거**하는 작업입니다.

즉, 릴레이션이 1NF 조건을 만족하고 부분 함수 종속성을 갖지 않으면, 그 릴레이션은 2NF가 됩니다.



![img](https://t1.daumcdn.net/cfile/tistory/997E834B5CCD2B031E)



위의 예제에서 정규화를 하기 전 테이블을 보면, 이름과 학과는 후보키입니다.

후보키 중 하나인( 진부분집합 ) 이름을 알면 학년을 알 수 있으므로 함수 종속이 존재하고 있습니다.

2NF를 이러한 함수 종속을 제거하는 작업입니다.



함수 종속을 제거하려면 원래의 릴레이션을 무손실 분해시켜야 합니다.

- 종속 관계가 있는 속성만 추출해서( projection, 프로젝션 )해서 새로운 릴레이션을 만듭니다.

- - 즉 이름과 학년을 애트리뷰트로 갖는 새로운 릴레이션이 생성됩니다.

- 기존에 있던 원래 릴레이션은 떨어져나간 애트리뷰트( 학년 )를 제외한 릴레이션으로 존재합니다.

함수 종속을 제거함으로써 이렇게 두 개의 릴레이션으로 쪼개지고, 두 릴레이션을 결합하면 원래의 릴레이션이 되므로 무손실 분해가 이뤄졌습니다.

![img](https://t1.daumcdn.net/cfile/tistory/994B844B5CCD2E0D18)



### 제 3 정규형

3NF는 **추이 함수 종속성**( Transitive Dependency )을 제거하는 작업입니다.



추이 함수 종속성은 키가 아닌 애트리뷰트 사이의 함수 종속성을 의미합니다.

예를 들어, 키가 아닌 애트리뷰트 X, Y가 있고, X를 알면 Y값을 알 수 있는 함수 종속성이 있다고 가정해보겠습니다.

3NF는 X와 Y 사이의 함수 종속성을 제거 하는 과정입니다.

2NF는 후보키와 키가 아닌 애트리뷰트 사이의 함수 종속성을 제거했다는 점에서 차이가 있습니다.

![img](https://t1.daumcdn.net/cfile/tistory/998525465CCD2E5719)

참고로 슈퍼키를 알면 X를 알 수 있고, X를 알면 Y를 알 수 있으므로 추이 함수 종속성이라는 말이 붙었습니다.





![img](https://t1.daumcdn.net/cfile/tistory/999818335CCD32551B)



위의 예제는 후보키인 학번을 알면 우편번호를 알 수 있고, 우편번호를 알면 나머지 주소를 알 수 있기 때문에 추이 함수 종속관계입니다.

따라서 우편번호 애트리뷰트를 기준으로 릴레이션을 분해합니다.

릴레이션을 분해하는 방법은 2NF와 동일합니다.

### BCNF

BCNF는 키가 아닌 애트리뷰트에서 후보키의 진부부집합에 대한 함수 종속성을 제거하는 작업입니다.

![img](https://t1.daumcdn.net/cfile/tistory/99F061395CCD34392A)





![img](https://t1.daumcdn.net/cfile/tistory/99BEDA3A5CCD40E208)



위의 예제는 수강신청 릴레이션입니다.

어떤 학생이 어떤 교수의 교과목을 선택했는지에 대한 애트리뷰트가 있으며, 학번과 교과목이 후보키입니다.



기존의 릴레이션은 3NF를 만족합니다.

어떤 학생이 어떤 교과목을 선택했는지의 조합에따라 교수가 정해지기 때문에 2NF를 만족합니다.

또한 키가 아닌 애트리뷰트인 교수번호를 통해 교수이름을 알 수 있으므로 릴레이션을 분할하여 3NF를 만족합니다.



그런데 교수는 특정 과목만 가르치기 때문에 교수번호를 알면 교과목을 알 수 있는 상황입니다.

이는 2NF, 3NF에서 볼 수 없었던 함수 종속입니다.

따라서 교과목은 후보키로 되어 있고 교수번호는 후보키가 아니므로, 교수번호를 후보키로 지정하고 교과목은 후보키에서 제외합니다.



정리하면 다음과 같습니다.

- 기존에 (학번, 교과목)을 후보키로 하여, 3NF를 만족하는 수강신청 릴레이션 존재

- 키 애트리뷰트가 아닌 교수 번호를 통해 후보키인 교과목을 알 수 있음

- - BCNF는 이러한 경우의 함수 종속을 제거합니다.

- 교수번호를 후보키로 지정, 교과목은 후보키에서 제외



BCNF는 함수 종속성이 모두 제거된 상태의 정규형입니다.

앞서 2NF와 3NF 그리고 BCNF를 거쳐 모든 경우의 수에 대해 함수 종속성을 제거했기 때문입니다.

이로써 BCNF 이상에서 함수 종속성에 의한 무손실 분해를 할 수 없습니다.



## 비정규화

 과도한 정규화로 인해서 테이블의 수가 증가하게 되면, 다수의 JOIN이 발생함에 따라서 성능 저하가 발생할 수 있다. 보통의 경우 정규화 과정을 모두 거친 다음 마지막 단계에서 비정규화를 실시한다. 

- 중복 컬럼의 허용
  특정테이블(계약) 액세스시 자주 조회되는 컬럼들이 다른 테이블에 있는 경우 해당 컬럼을 두개의 테이블에 중복시키는 것을 고려한다. 특히 해당 컬럼을 액세스 하기 위해서 주로 조인이 일어나고 그 외에는 거의 발생하지 않는 경우에는 중복 컬럼의 사용을 권장한다.

- 유도(Drived) 컬럼의 생성
  합계,평균,개수 등 다른 컬럼의 값을 조합하여 결과를 얻어야 하는 트랜젝션이 많고 상대적으로 해당 테이블에 변경(DML)작업이 적은 경우, 원하는 값(합계,평균)을 가지는 컬럼을 추가하는 것을 검토한다.

- 테이블의 병합 및 분리
  - 테이블의 컬럼 중 주로 일부만 사용되고 가끔 테이블의 전체 컬럼이 사용되는 경우는 1:1 관계를 갖는 2개의 테이블로 분리하는 것을 고려한다. 역으로 1:1 관계를 갖는 테이블이 서로 자주 조인하는 경우에는 두개의 테이블을 하나로 병합하는 것을 고려한다.
  - 주종(Master – Detail )관계인 테이블의 관계수(occurrence)가 최고 5이하이고 컬럼이 매우 적은 경우이면서 두개의 테이블이 자주 조인되는 경우에는 종속(Detail)테이블을 마스터(Master) 테이블에 병합하여 중복 컬럼으로 사용하는 것을 고려한다.



- 분산환경에서 테이블의 중복 또는 스냅샷( Snapshot)의 사용
  - 다른 노드의 테이블을 액세스(특히 Join)하는 트랜젝션이 실시간의 데이터를 요구하지 않는 경우

  - OLTP에 사용되는 테이블로 OLTP트랜젝션이 실행되는 시간에 배치작업을 해야 하고, 작업이 실시간의 데이터를 요구하지 않는 경우

-  마스터(원장)테이블과 이력테이블의 결합
  대부분 마스터와 이력은 분리하여 별개의 테이블로 관리하는 것이 유지보수를 하는데 편리하며, 배치 작업시에도 주로 유효한 현재 데이터를 가진 마스터 테이블을 대상으로 하게 되는 경우가 일반적이므로 액세스의 성능에도 도움을 준다. 그러나 때때로 이력과 마스터를 합하여 배치작업을 실행하거나 OLTP에서 이력과 마스터를 둘 다 동시에 액세스 하는 업무가 있는 경우, 두개의 테이블이 아닌 하나의 테이블에 현재와 이력데이터 모두를 관리하는 것이 효율적이 될 수 있다. 이런 경우 테이블의 키를 “기존의 유일키컬럼 + 유효시작일자 + 유효종료일자”를 사용하면 데이터 액세스시 스캔하는 범위를 최소화 할 수 있다. 이러한 경우에 단점은 애플리케이션에서 데이터를 입력/변경하는 시점에 바로 이전의 데이터를 찾아서 이를 동시에 변경해야 하는 추가적인 일이 생긴다. 따라서 데이터 액세스 성능과 데이터 관리 측면을 고려하여 결정되어야 한다.

 



## 트랜잭션(Transaction)

### 트랜잭션(Transaction) 이란

데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합이다.

>  예를들어, A계좌에서 B계좌로 일정 금액을 이체한다고 가정하자. A계좌의 잔액을 확인한다. A계좌의 금액에서 이체할 금액을 빼고 다시 저장한다.B계좌의 잔액을 확인한다. B계좌의 금액에서 이체할 금액을 더하고 다시 저장한다. 이러한 과정들이 모두 합쳐져 계좌이체라는 하나의 작업단위를 구성한다. 하나의 트랜잭션은 Commit 되거나 Rollback 된다.

### Commit 연산

 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

### Rollback 연산

 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.
Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.

**데이터베이스 응용 프로그램은 트랜잭션들의 집합으로 정의 할 수 있다.**



### 트랜잭션의 성질(ACID)

- 원자성(Atomicity), All or nothing

   트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.

- 일관성(Consistency)

  트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다.

- 독립성(Isolation)

  하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.

- 지속성(Durability)

  성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.

### 트랜잭션의 필요성

- 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우

- 각각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른 지점에서 저장한 잔액을 덮어 쓰는 경우

위와 같은 상황이 발생되지 않도록 방지하기 위해, 즉, 트랜잭션의 성질인 ACID를 제공받기위해 트랜잭션을 사용한다.

### 트랜잭션의 상태

![](C:\Users\multicampus\Documents\카카오톡 받은 파일\KakaoTalk_20200711_020708773.png)

- 활동(Active)

  트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태

- 장애(Failed)

  트랜잭션이 실행에 오류가 발생하여 중단된 상태

- 철회(Aborted)

  트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

- 부분 완료(Partially Committed)

  트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

- 완료(Committed)

  트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

### 트랜잭션 격리 수준(Transaction Isolation Level)

**Isolation Level 이란?**
트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준

**Isolation Level 의 필요성**
데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다. 그래서 ***Locking*** 이라는 개념이 등장한다.

> Locking: 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것 

 하지만 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어지게 된다. 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리 될 여지가 있다. 그래서 최대한 효율적인 Locking 방법이 필요하다.

**Isolation Level 의 종류**

- Read Uncommitted (레벨 0)

  SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level
  트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
  따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted 혹은 Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
  데이터베이스의 일관성을 유지할 수 없다.

- Read Committed (레벨 1)

  SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level
  트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.
  Commit이 이루어진 트랜잭션만 조회할 수 있다.
  따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.
  SQL Server가 Default로 사용하는 Isolation Level

- Repeatable Read (레벨 2)

  트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
  트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
  따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다.

- Serializable (레벨 3)

  트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
  완벽한 읽기 일관성 모드를 제공한다.
  따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.
  Isolation level 조정은 동시성이 증가되는데 반해 데이터 무결성에 문제가 발생할 수 있고, 데이터의 무결성을 유지하는 데 반해 동시성이 떨어질 수 있다.
  레벨이 높아질수록 비용이 높아진다.

**낮은 단계의 Isolation Level 이용시 발생하는 현상**

![](C:\Users\multicampus\Documents\카카오톡 받은 파일\KakaoTalk_20200711_020708593.png)

- Dirty Read

  커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상

  어떤 트랜잭션에서 아직 실행이 끝난지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 되는 경우

- Non-Repeatable Read

  한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비 일관성 현상

- Phantom Read

  한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
  이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타난다.



## 교착 상태(Dead Lock)

여러 개의 트랜잭션(Transaction)들이 실행을 하지 못하고 서로 무한정 기다리는 상태

### 교착 상태 탐지 방법

Union-find 알고리즘을 이용해서 사이클이 존재하는지의 여부로 확인 가능하다. 

1. 타임스탬프 기법

   트랜잭션을 기준으로 하는 것이 아니라 각 데이터를 기준으로 하여 시간 순서대로 제어하는 기법. 

   -> 트랜잭션에서 데이터를 처리하는 부분을 Read와 Write로 나누어 계산하는 방법. 처음부터 시간 순서대로 제어를 하고 있기 때문에 시간 측면의 문제가 발생하기 않고 포기하는 경우 마지막 순서로 다시 해당 데이터를 처리할 수 있도록 들어간다. 

   |                 | Read X | Write X |
   | --------------- | ------ | ------- |
   | After Read X    | commit | commit  |
   | After Write X   | commit | commit  |
   | While reading X | commit | die     |
   | While writing X | die    | die     |

   

2. 낙관적 병행 제어 기법 

   트랜잭션이 실행되는 동안에는 아무런 검사를 하지 않고, 트랜잭션이 실행된 이후에 검사하여 문제가 있다면 되돌리는 방법.

   판독 단계 -> 확인 단계 -> 기록 단계로 나눠져 있고 확인 단계를 거친 트랜잭션에 한해서만 기록단계를 수행할 수 있도록 한다. 

### 교착 상태 해결 방법

1. 예방 기법 

   각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 Locking 해주는 것. 

   데이터가 많이 필요하면 사실상 모든 데이터를 전부 Locking 해야 하며 트랜잭션의 병행성을하지 못한다. 

   몇몇 트랜잭션은 계속해서 처리를 못하게 되는 기아 상태가 발생할 수 있다. 

2. 회피 기법 : 자원을 할당할 때 시간  스탬프를 사용하여 교착상태가 일어나지 않도록 회피하는 방법

   1. **Wait-Die방식** : 트랜잭션  Ti 가 Tj 에 의해 로킹된 데이터를 요청할 때 Ti가 먼저 들어온 트랜젝션이라면 기다립니다. 반면에 나중에 들어온 트랜젝션이라면 포기하고 나중에 다시 요청합니다. 즉, 다른 트랜젝션이 데이터를 점유하고 있을 때 기다리거나 포기하는 방식.
   2. **wound-wait 방식**: 트랜젝션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때 Ti가 먼저 들어온 트랜젝션이라면 데이터를 선점합니다. 반면에 Ti가 나중에 들어온 트랜젝션이라면 기다립니다.



## 인덱스

### 인덱스

RDBMS에서 검색 속도를 높이기 위해 사용하는 하나의 자료구조. 해당 Table의 컬럼을 색인화(따로 파일로 저장) 하여 검색시 해당 Table의 레코드를 full scan 하는 게 아니라 색인화 되어있는 index 파일을 검색하여 검색속도를 빠르게 한다. tree 구조로 색인화한다. 데이터 형식 때문에 인덱스 될 수 없는 필드도 있고 기본키는 자동으로 인덱스된다. 

### 인덱스의 장점

- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
- 질의나 보고서에서 그룹화 작업의 속도를 향상시킨다.
- 인덱스를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.



### 인덱스의 단점

- 자원을 많이 소비하게 된다(인덱스 테이블이라는 테이블이 생성되므로)
- SELECT를 제외한 insert, update, delete에 대한 성능 저하



### B+ tree

많은 인덱스 알고리즘 중에 자세히 알아볼 인덱스는 **B+트리** 입니다.

RDB에서 인덱스는 일반적으로 B+트리 자료구조를 이용하여 검색을 수행하며,

B+ 트리는 다음과 같이 구성됩니다.

![img](https://t1.daumcdn.net/cfile/tistory/99713A3D5CDFA03E15)

참고 : https://iq.opengenus.org/b-tree-search-insert-delete-operations/

- 실제 데이터가 저장된 **리프노드**( Leaf nodes )
- 리프노드까지의 경로 역할을 하는 **논리프노드**( Non-leaf nodes )
- 경로의 출발점이 되는 **루트 노드**( Root node )

B+트리는 리프노드에 이르기까지에 대한 자식 노드에 포인터가 저장되어 있습니다.

즉, B+트리의 검색은 루트노드에서 어떤 리프 노드에 이르는 한 개의 경로만 검색하면 되므로, 매우 효율적이다.

위와 같은 구조로 인해, B+ 트리 인덱스는 등가 비교는 물론 범위 검색에도 사용될 수 있습니다.

- 등가 비교

- - WHERE key = 123

- 범위 검색

- - WHERE key BETWEEN 100 AND 200

  - LIKE 검색의 와일드카드는 전방 일치여야 인덱스 효과를 얻을 수 있습니다.

  - - WHERE key LIKE 'foo%'
    - Leaf node에서 문자열이 사전 순서대로 정렬돼 있기 때문에 전방 일치가 아닌 LIKE 검색은 물리적으로 불가능합니다.



## 뷰

DB 객체를 보호하는 방법으로 사용자에게 권한(privilage)을 부여하는 방법이 있습니다.

이와 달리, 뷰 테이블**( 원본 테이블을 그대로 두고, 노출하고 싶은 필요한 정보들만 모아서 가상 테이블 )**을 만들어 보호하는 방법이 있습니다.

즉, 사용자가 보는 테이블은 실제 테이블이 아닌 가상의 테이블이므로, 원본 테이블에 영향을 주지 않으므로 DB객체를 보호할 수 있습니다.



![img](https://t1.daumcdn.net/cfile/tistory/99B69D375A7E744136)

위의 쿼리는 VIEW_SAMPLE라는 이름의 뷰를 생성하는 쿼리입니다.

원본 테이블( base table )은 Student이고, VIEW_SAMPLE은 stu_no와 name만을 Attribute로 갖는 가상의 테이블이죠.

이와 같이 보여주고 싶은 Attribute만 선택해서 뷰를 만들 수 있습니다.



뷰는 가상의 테이블이지만, 일반적인 테이블처럼 쿼리를 수행할 수 있습니다.

단, SELECT 쿼리에 대해서는 제약조건이 없지만 UPDATE, DELETE, INSERT에 대해서는 제약조건이 있습니다.

여기서 말하는 제약조건이란, **뷰의 Attribute에는 base table의 primary key가 존재해야 한다는 것**입니다.



그런데 사실 뷰의 목적은 데이터 조회에 있습니다.

따라서 뷰의 데이터를 조회할 때 일반 테이블처럼 쿼리를 작성해도 됩니다.









### 뷰를 사용하는 이유

**독립성을 보장함**에 있습니다.

즉, 외부 스키마와 개념 스키마 간의 독립성( 3-level architecture의 logical interface )을 보장하기 위함입니다.

뷰가 독립성을 보장하는 개념은 다음과 같습니다.

- **growth**

- - 뷰에 새로운 Attribute가 추가 되어도 base table에는 영향을 주지 않습니다.
  - 반대로 base table에 새로운 Attribute가 추가되어도 뷰에는 영향을 주지 않습니다.
  - 따라서 base table과 사용자가 실제로 보는 뷰 간의 데이터 독립성을 보장합니다.

- **restructuring**

- - 뷰를 통해 base table 중 자주 쓰이는 필드만 골라 작은 테이블로 만들 수 있습니다.
  - 즉, 매번 base table에 접근할 필요 없이 뷰에 접근함으로써 연산을 줄일 수 있으며, 필요한 데이터만 보여줌으로써 보안성을 높일 수 있습니다.